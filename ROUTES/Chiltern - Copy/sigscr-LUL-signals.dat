///////////////////////////////////////////////////////////////////////////////
// LUL Signal scripts V4.0 - Jimi Ibbett, Feb 2008. Used on LUL District Line.
// Includes LUL Tunnel signal set and multi-path (MP) Shunts/Theaters.
// Total 66 Head scripts defined.
// Thanks and acknowlegement to TONY FORMOSO for inspiration and ideas.
///////////////////////////////////////////////////////////////////////////////
SCRIPT LUL-CoActing

// 2 Aspect Colour Light semi or Auto Co-Acting (tunnel size)
// MUST be placed immediately in rear of the semi or auto signal it repeats
// Type = INFO

	extern float	def_draw_state ();
	extern float	next_sig_lr();
	extern float	state;
	extern float	draw_state;
	float			next_state;

	// Find next NORMAL (semi or auto) signal. If at STOP, set CoActor to Restricting, else Clear.
	next_state = next_sig_lr (SIGFN_NORMAL);
	if ( next_state ==# SIGASP_STOP ||
	     next_state ==# SIGASP_RESTRICTING )
	{
		state = SIGASP_RESTRICTING; // Red
	}
	else
	{
		state = SIGASP_CLEAR_2; // Green
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
SCRIPT LUL-ShuntMP

// Multi-path (MP) Shunt disk (permissive)
// Works with LUL-ShuntMP-Tn theater heads
// Type = INFO

	extern float	this_sig_lr ();
	extern float	draw_state;
	extern float	state;

// Show clear (off) indication if any co-located theater heads are clear

	if ( this_sig_lr (SIGFN_SHUNTING) ==# SIGASP_CLEAR_2 )	// Any co-located theater clear?
	{
		draw_state = 1; // off
		state = SIGASP_CLEAR_2;
	}
	else
	{	
		draw_state = 0; // on
		state = SIGASP_RESTRICTING;
	}

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-ShuntMP-T1

// Multi-path (MP) Shunt Theatre '1' signal head (optional)
// Works with LUL-ShuntMP multi-path shunt disc
// Type = SHUNTING

	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

// Determine if this theater should be lit (route is set and block clear)

	if ( //!enabled ||							// Not enabled/cleared to show natural state?
		block_state() !=# BLOCK_CLEAR ||				// Block not ahead clear?
		!route_set() )							// Switch not set as per link?

	{
		state = SIGASP_RESTRICTING;
		draw_state = 0;
	}
	else
      {
		state = SIGASP_CLEAR_2;
		draw_state = 1;
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-ShuntMP-T2

// Multi-path (MP) Shunt Theatre '2' signal head (optional)
// Works with LUL-ShuntMP multi-path shunt disc
// Type = SHUNTING

	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

// Determine if this theater should be lit (route is set and block clear)

	if ( //!enabled ||							// Not enabled/cleared to show natural state?
		block_state() !=# BLOCK_CLEAR ||				// Block not ahead clear?
		!route_set() )							// Switch not set as per link?

	{
		state = SIGASP_RESTRICTING;
		draw_state = 0;
	}
	else
      {
		state = SIGASP_CLEAR_2;
		draw_state = 1;
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-ShuntMP-T3

// Multi-path (MP) Shunt Theatre '3' signal head (optional)
// Works with LUL-ShuntMP multi-path shunt disc
// Type = SHUNTING

	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

// Determine if this theater should be lit (route is set and block clear)

	if ( //!enabled ||							// Not enabled/cleared to show natural state?
		block_state() !=# BLOCK_CLEAR ||				// Block not ahead clear?
		!route_set() )							// Switch not set as per link?

	{
		state = SIGASP_RESTRICTING;
		draw_state = 0;
	}
	else
      {
		state = SIGASP_CLEAR_2;
		draw_state = 1;
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-ShuntMP-T4

// Multi-path (MP) Shunt Theatre '4' signal head (optional)
// Works with LUL-ShuntMP multi-path shunt disc
// Type = SHUNTING

	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

// Determine if this theater should be lit (route is set and block clear)

	if ( //!enabled ||							// Not enabled/cleared to show natural state?
		block_state() !=# BLOCK_CLEAR ||				// Block not ahead clear?
		!route_set() )							// Switch not set as per link?

	{
		state = SIGASP_RESTRICTING;
		draw_state = 0;
	}
	else
      {
		state = SIGASP_CLEAR_2;
		draw_state = 1;
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-ShuntMP-T5

// Multi-path (MP) Shunt Theatre '5' signal head (optional)
// Works with LUL-ShuntMP multi-path shunt disc
// Type = SHUNTING

	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

// Determine if this theater should be lit (route is set and block clear)

	if ( //!enabled ||							// Not enabled/cleared to show natural state?
		block_state() !=# BLOCK_CLEAR ||				// Block not ahead clear?
		!route_set() )							// Switch not set as per link?

	{
		state = SIGASP_RESTRICTING;
		draw_state = 0;
	}
	else
      {
		state = SIGASP_CLEAR_2;
		draw_state = 1;
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-ShuntMP-T6

// Multi-path (MP) Shunt Theatre '6' signal head (optional)
// Works with LUL-ShuntMP multi-path shunt disc
// Type = SHUNTING

	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

// Determine if this theater should be lit (route is set and block clear)

	if ( //!enabled ||							// Not enabled/cleared to show natural state?
		block_state() !=# BLOCK_CLEAR ||				// Block not ahead clear?
		!route_set() )							// Switch not set as per link?

	{
		state = SIGASP_RESTRICTING;
		draw_state = 0;
	}
	else
      {
		state = SIGASP_CLEAR_2;
		draw_state = 1;
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-ShuntMP-T7

// Multi-path (MP) Shunt Theatre '7' signal head (optional)
// Works with LUL-ShuntMP multi-path shunt disc
// Type = SHUNTING

	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

// Determine if this theater should be lit (route is set and block clear)

	if ( //!enabled ||							// Not enabled/cleared to show natural state?
		block_state() !=# BLOCK_CLEAR ||				// Block not ahead clear?
		!route_set() )							// Switch not set as per link?

	{
		state = SIGASP_RESTRICTING;
		draw_state = 0;
	}
	else
      {
		state = SIGASP_CLEAR_2;
		draw_state = 1;
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-ShuntMP-T8

// Multi-path (MP) Shunt Theatre '8' signal head (optional)
// Works with LUL-ShuntMP multi-path shunt disc
// Type = SHUNTING

	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

// Determine if this theater should be lit (route is set and block clear)

	if ( //!enabled ||							// Not enabled/cleared to show natural state?
		block_state() !=# BLOCK_CLEAR ||				// Block not ahead clear?
		!route_set() )							// Switch not set as per link?

	{
		state = SIGASP_RESTRICTING;
		draw_state = 0;
	}
	else
      {
		state = SIGASP_CLEAR_2;
		draw_state = 1;
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-NRS-Repeater

// NR Repeater Semaphore Disc
// Mechanical semaphore repeater for Kew Gdns

	extern float	def_draw_state ();
	extern float	next_sig_lr();
	extern float	state;
	extern float	draw_state;
	float			next_state;

	// Find next NORMAL (stop or auto) signal.
	// If at STOP or RESTRICTING, set Repeater at Approach, else Clear.

	next_state = next_sig_lr (SIGFN_NORMAL);

	if ( next_state ==# SIGASP_STOP ||
	     next_state ==# SIGASP_RESTRICTING )
	{
		state = SIGASP_APPROACH_1; // Yellow
	}
	else
	{
		state = SIGASP_CLEAR_2; // Green
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-NR3A

// LUL National Rail 3-light (Automatic)
// Red (stop) if block occupied.
// Else tests state of next signal: yellow if next is red, else green

	extern float	block_state ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	float			next_state;

// If required, show the 'stop' indication.

	if (block_state() !=# BLOCK_CLEAR)	// Block occupied?
	{
		state = SIGASP_STOP; // Red
	}

// Block ahead is clear - update based on state of
// next signal head.

	else
	{
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_STOP ||
		    next_state ==# SIGASP_RESTRICTING)
		{
			state = SIGASP_APPROACH_1; //  Yellow
		}
		else
		{
			state = SIGASP_CLEAR_2; // Green 
		}
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-NR3

// LUL National Rail 3-light (Controlled = Semi-automatic)
// Red (stop) if block occupied or route not set.
// Else tests state of next signal: yellow if next is red, else green

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float			next_state;

// If required, show the 'stop' indication.

	if (!enabled ||								// Not enabled/cleared to show natural state?
		block_state() !=# BLOCK_CLEAR ||				// Block ahead not clear?
		!route_set())							// Switch not set as per link?
	{
		state = SIGASP_STOP; // Red
	}

// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.

	else
	{
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_STOP ||
		    next_state ==# SIGASP_RESTRICTING)
		{
			state = SIGASP_APPROACH_1; //  Yellow
		}
		else
		{
			state = SIGASP_CLEAR_2; // Green 
		}
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-Fog-Rptr

// 2 Aspect Colour Light Fog Repeater

	extern float	def_draw_state ();
	extern float	next_sig_lr();
	extern float	state;
	extern float	draw_state;
	float			next_state;

	// Find next NORMAL (stop or auto) signal. If at STOP or RESTRICTING, set Repeater at Approach, else Clear.

	next_state = next_sig_lr (SIGFN_NORMAL);
	if ( next_state ==# SIGASP_STOP ||
	     next_state ==# SIGASP_RESTRICTING )
	{
		state = SIGASP_APPROACH_1; // Yellow
	}
	else
	{
		state = SIGASP_CLEAR_2; // Green
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-Trainstop

// Trainstop (Left or Right, Single or Dual Ramp = suffix LS, LD, RS, or RD)
// NOTE: This object MUST be placed just behind the STOP signal it protects!
// It tests the state of the STOP signal immediately ahead of it.

	extern float	def_draw_state ();
	extern float	next_sig_lr();
	extern float	state;
	extern float	draw_state;
	float			next_state;

	// Find next NORMAL (stop or auto) signal.
	// If at STOP, set Trainstop to Restricting (raised), else Clear (lowered).

	next_state = next_sig_lr (SIGFN_NORMAL);
	if ( next_state ==# SIGASP_STOP )
	{
		state = SIGASP_RESTRICTING;
		draw_state = 0;
	}
	else
      {
		state = SIGASP_CLEAR_2;
		draw_state = 1;
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-Shunt

// Shunt disk (permissive)

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float			this_state;

// Determine if shunt should be ON (STOP)
	this_state = this_sig_lr (SIGFN_NORMAL);
	if ( //!enabled ||				// Not enabled/cleared to show natural state?
		block_state() !=# BLOCK_CLEAR ||	// Block not ahead clear?
		this_state ==# SIGASP_CLEAR_2 ||	// Main head not set to allow shunt?
		this_state ==# SIGASP_APPROACH_1 || 
		!route_set() )				// Switch not set as per link?

	{
		state = SIGASP_RESTRICTING;
		draw_state = 0;
	}
	else
      {
		state = SIGASP_CLEAR_2;
		draw_state = 1;
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-Theater-1

// Theatre '1' signal head
// NOTE: This object MUST be placed just behind the STOP ahead of it (co-located)
// It tests the state of the signal immediately ahead of it.
// LEDS are lit if co-located signal (ahead) is not STOP and specific route is set.

	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	draw_state;

// If required, show the 'stop' indication.
	if ( next_sig_lr (SIGFN_NORMAL) ==# SIGASP_STOP ||		// Co-located signal at STOP?
		!route_set() )							// Switch not set as per link?
	{
		draw_state = 0;	// LEDS off
	}
	else
	{	
		draw_state = 1;	// LEDS on
	}

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-Theater-2

// Theatre '2' signal head
// NOTE: This object MUST be placed just behind the STOP ahead of it (co-located)
// It tests the state of the signal immediately ahead of it.
// LEDS are lit if co-located signal (ahead) is not STOP and specific route is set.

	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	draw_state;

// If required, show the 'stop' indication.
	if ( next_sig_lr (SIGFN_NORMAL) ==# SIGASP_STOP ||		// Co-located signal at STOP?
		!route_set() )							// Switch not set as per link?
	{
		draw_state = 0;	// LEDS off
	}
	else
	{	
		draw_state = 1;	// LEDS on
	}

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-Theater-3

// Theatre '3' signal head
// NOTE: This object MUST be placed just behind the STOP ahead of it (co-located)
// It tests the state of the signal immediately ahead of it.
// LEDS are lit if co-located signal (ahead) is not STOP and specific route is set.

	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	draw_state;

// If required, show the 'stop' indication.
	if ( next_sig_lr (SIGFN_NORMAL) ==# SIGASP_STOP ||		// Co-located signal at STOP?
		!route_set() )							// Switch not set as per link?
	{
		draw_state = 0;	// LEDS off
	}
	else
	{	
		draw_state = 1;	// LEDS on
	}

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-Theater-4

// Theatre '4' signal head
// NOTE: This object MUST be placed just behind the STOP ahead of it (co-located)
// It tests the state of the signal immediately ahead of it.
// LEDS are lit if co-located signal (ahead) is not STOP and specific route is set.

	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	draw_state;

// If required, show the 'stop' indication.
	if ( next_sig_lr (SIGFN_NORMAL) ==# SIGASP_STOP ||		// Co-located signal at STOP?
		!route_set() )							// Switch not set as per link?
	{
		draw_state = 0;	// LEDS off
	}
	else
	{	
		draw_state = 1;	// LEDS on
	}

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-Theater-5

// Theatre '5' signal head
// NOTE: This object MUST be placed just behind the STOP ahead of it (co-located)
// It tests the state of the signal immediately ahead of it.
// LEDS are lit if co-located signal (ahead) is not STOP and specific route is set.

	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	draw_state;

// If required, show the 'stop' indication.
	if ( next_sig_lr (SIGFN_NORMAL) ==# SIGASP_STOP ||		// Co-located signal at STOP?
		!route_set() )							// Switch not set as per link?
	{
		draw_state = 0;	// LEDS off
	}
	else
	{	
		draw_state = 1;	// LEDS on
	}

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-Theater-6

// Theatre '6' signal head
// NOTE: This object MUST be placed just behind the STOP ahead of it (co-located)
// It tests the state of the signal immediately ahead of it.
// LEDS are lit if co-located signal (ahead) is not STOP and specific route is set.

	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	draw_state;

// If required, show the 'stop' indication.
	if ( next_sig_lr (SIGFN_NORMAL) ==# SIGASP_STOP ||		// Co-located signal at STOP?
		!route_set() )							// Switch not set as per link?
	{
		draw_state = 0;	// LEDS off
	}
	else
	{	
		draw_state = 1;	// LEDS on
	}

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-Theater-7

// Theatre '7' signal head
// NOTE: This object MUST be placed just behind the STOP ahead of it (co-located)
// It tests the state of the signal immediately ahead of it.
// LEDS are lit if co-located signal (ahead) is not STOP and specific route is set.

	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	draw_state;

// If required, show the 'stop' indication.
	if ( next_sig_lr (SIGFN_NORMAL) ==# SIGASP_STOP ||		// Co-located signal at STOP?
		!route_set() )							// Switch not set as per link?
	{
		draw_state = 0;	// LEDS off
	}
	else
	{	
		draw_state = 1;	// LEDS on
	}

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-Theater-8

// Theatre '8' signal head
// NOTE: This object MUST be placed just behind the STOP ahead of it (co-located)
// It tests the state of the signal immediately ahead of it.
// LEDS are lit if co-located signal (ahead) is not STOP and specific route is set.

	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	draw_state;

// If required, show the 'stop' indication.
	if ( next_sig_lr (SIGFN_NORMAL) ==# SIGASP_STOP ||		// Co-located signal at STOP?
		!route_set() )							// Switch not set as per link?
	{
		draw_state = 0;	// LEDS off
	}
	else
	{	
		draw_state = 1;	// LEDS on
	}

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-Theater-N

// Theatre 'N' signal head
// NOTE: This object MUST be placed just behind the STOP ahead of it (co-located)
// It tests the state of the signal immediately ahead of it.
// LEDS are lit if co-located signal (ahead) is not STOP and specific route is set.

	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	draw_state;

// If required, show the 'stop' indication.
	if ( next_sig_lr (SIGFN_NORMAL) ==# SIGASP_STOP ||		// Co-located signal at STOP?
		!route_set() )							// Switch not set as per link?
	{
		draw_state = 0;	// LEDS off
	}
	else
	{	
		draw_state = 1;	// LEDS on
	}

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-Theater-D

// Theatre 'D' signal head
// NOTE: This object MUST be placed just behind the STOP ahead of it (co-located)
// It tests the state of the signal immediately ahead of it.
// LEDS are lit if co-located signal (ahead) is not STOP and specific route is set.

	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	draw_state;

// If required, show the 'stop' indication.
	if ( next_sig_lr (SIGFN_NORMAL) ==# SIGASP_STOP ||		// Co-located signal at STOP?
		!route_set() )							// Switch not set as per link?
	{
		draw_state = 0;	// LEDS off
	}
	else
	{	
		draw_state = 1;	// LEDS on
	}

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-Shunt-T1

// Shunt Theatre '1' signal head

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	draw_state;

// If required, show the 'stop' indication.
	if ( this_sig_lr (SIGFN_SHUNTING) ==# SIGASP_RESTRICTING ||	// Our shunt disc not clear?
		!route_set() )							// Switch not set as per link?
	{
		draw_state = 0;
	}
	else
	{	
		draw_state = 1;
	}

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-Shunt-T2

// Shunt Theatre '2' signal head

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	draw_state;

// If required, show the 'stop' indication.
	if ( this_sig_lr (SIGFN_SHUNTING) ==# SIGASP_RESTRICTING ||	// Our shunt disc not clear?
		!route_set() )							// Switch not set as per link?
	{
		draw_state = 0;
	}
	else
	{	
		draw_state = 1;
	}

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-Shunt-T3

// Shunt Theatre '3' signal head

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	draw_state;

// If required, show the 'stop' indication.
	if ( this_sig_lr (SIGFN_SHUNTING) ==# SIGASP_RESTRICTING ||	// Our shunt disc not clear?
		!route_set() )							// Switch not set as per link?
	{
		draw_state = 0;
	}
	else
	{	
		draw_state = 1;
	}

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-Shunt-TN

// Shunt Theatre 'N' signal head

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	draw_state;

// If required, show the 'stop' indication.
	if ( this_sig_lr (SIGFN_SHUNTING) ==# SIGASP_RESTRICTING ||	// Our shunt disc not clear?
		!route_set() )							// Switch not set as per link?
	{
		draw_state = 0;
	}
	else
	{	
		draw_state = 1;
	}

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-Shunt-TD

// Shunt Theatre 'D' signal head

	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	draw_state;

// If required, show the 'stop' indication.
	if ( this_sig_lr (SIGFN_SHUNTING) ==# SIGASP_RESTRICTING ||	// Our shunt disc not clear?
		!route_set() )							// Switch not set as per link?
	{
		draw_state = 0;
	}
	else
	{	
		draw_state = 1;
	}

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-Stop

// 2 Aspect Colour Light Stop (semi-auto)

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float			next_state;

// Determine STOP conditions
	if ( !enabled ||								// Not enabled/cleared to show natural state?
		block_state() !=# BLOCK_CLEAR )				// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
	else
      {
		state = SIGASP_CLEAR_2;  // Path set and block clear
	}

// If a co-located shunt link is clear or our route link is not set, allow restricted proceed
	if ( this_sig_lr (SIGFN_SHUNTING) ==# SIGASP_CLEAR_2 ||
	     !route_set() ) // Switch not set as per link?
	{
		state = SIGASP_RESTRICTING;	// Allow movement to turnout past main stop head
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-Auto

// 2 Aspect Colour Light Stop (Automatic)
// Only shows STOP if Block ahead is occupied, else clear

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float			next_state;

// Determine STOP conditions
	if (block_state() !=# BLOCK_CLEAR)				// Block ahead not clear?
	{
		state = SIGASP_STOP;	// Block occupied
	}
	else
      {
		state = SIGASP_CLEAR_2;  // Block clear
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-Repeater

// 2 Aspect Colour Light Repeater

	extern float	def_draw_state ();
	extern float	next_sig_lr();
	extern float	state;
	extern float	draw_state;
	float			next_state;

	// Find next NORMAL (stop or auto) signal. If at STOP, set Repeater at Approach, else Clear.
	next_state = next_sig_lr (SIGFN_NORMAL);
	if ( next_state ==# SIGASP_STOP ||
	     next_state ==# SIGASP_RESTRICTING )
	{
		state = SIGASP_APPROACH_1; // Yellow
	}
	else
	{
		state = SIGASP_CLEAR_2; // Green
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-Rpt-FixY

// 2 Aspect Colour Light Repeater -- fixed yellow

	extern float	def_draw_state ();
	extern float	next_sig_lr();
	extern float	state;
	extern float	draw_state;
	float			next_state;

	// Always at APPROACH_1 (Yellow)
	state = SIGASP_APPROACH_1; // Yellow

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-RI-Left

// Route Indicator Left

	extern float	block_state ();
	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	draw_state;
	extern float	enabled;
	float			this_state;


// Lights off if route not set, or stop sig at red.
	this_state = this_sig_lr (SIGFN_NORMAL);		// Get state of co-located stop head
	if ( this_state ==# SIGASP_STOP ||			// Main head not clear?
		!route_set() )					// Switch not set as per link?
	{
		draw_state = 0;					// Lights off
	}
	else
      {
		draw_state = 1;					// Lights on
	}

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-RI-Right

// Route Indicator Right

	extern float	block_state ();
	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	draw_state;
	extern float	enabled;
	float			this_state;


// Lights off if route not set, or stop sig at red.
	this_state = this_sig_lr (SIGFN_NORMAL);		// Get state of co-located stop head
	if ( this_state ==# SIGASP_STOP ||			// Main head not clear?
		!route_set())					// Switch not set as per link?
	{
		draw_state = 0;					// Lights off
	}
	else
      {
		draw_state = 1;					// Lights on
	}

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-RILR-Left

// Route Indicator Left (of L/R pair)

	extern float	block_state ();
	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	draw_state;
	extern float	enabled;
	float			this_state;


// Lights off if route not set, or stop sig at red.
	this_state = this_sig_lr (SIGFN_NORMAL);		// Get state of co-located stop head
	if ( this_state !=# SIGASP_CLEAR_2 ||		// Main head not clear?
		!route_set() )					// Switch not set as per link?
	{
		draw_state = 0;					// Lights off
	}
	else
      {
		draw_state = 1;					// Lights on
	}

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-RILR-Right

// Route Indicator Left  (of L/R pair)

	extern float	block_state ();
	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	draw_state;
	extern float	enabled;
	float			this_state;


// Lights off if route not set, or stop sig at red.
	this_state = this_sig_lr (SIGFN_NORMAL);		// Get state of co-located stop head
	if ( this_state !=# SIGASP_CLEAR_2 ||		// Main head not clear?
		!route_set() )					// Switch not set as per link?
	{
		draw_state = 0;					// Lights off
	}
	else
      {
		draw_state = 1;					// Lights on
	}

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-Rptr-RI-Left

// Repeater Route Indicator Left

	extern float	block_state ();
	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	draw_state;
	extern float	enabled;
	float			this_state;


// Lights off if route not set, or rptr sig at yellow.
	this_state = this_sig_lr (SIGFN_DISTANCE);	// Get state of co-located rptr head
	if ( this_state !=# SIGASP_CLEAR_2 ||		// Main head not clear?
		!route_set() )					// Switch not set as per link?
	{
		draw_state = 0;					// Lights off
	}
	else
      {
		draw_state = 1;					// Lights on
	}

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-Rptr-RI-Right

// Repeater Route Indicator Right

	extern float	block_state ();
	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	draw_state;
	extern float	enabled;
	float			this_state;


// Lights off if route not set, or rptr sig at yellow.
	this_state = this_sig_lr (SIGFN_DISTANCE);	// Get state of co-located rptr head
	if ( this_state !=# SIGASP_CLEAR_2 ||		// Main head not clear?
		!route_set())					// Switch not set as per link?
	{
		draw_state = 0;					// Lights off
	}
	else
      {
		draw_state = 1;					// Lights on
	}

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-Rptr-RILR-Left

// Repeater Route Indicator Left (of L/R pair)

	extern float	block_state ();
	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	draw_state;
	extern float	enabled;
	float			this_state;


// Lights off if route not set, or rptr sig at yellow.
	this_state = this_sig_lr (SIGFN_DISTANCE);	// Get state of co-located rptr head
	if ( this_state !=# SIGASP_CLEAR_2 ||		// Main head not clear?
		!route_set() )					// Switch not set as per link?
	{
		draw_state = 0;					// Lights off
	}
	else
      {
		draw_state = 1;					// Lights on
	}

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-Rptr-RILR-Right

// Repeater Route Indicator Left   (of L/R pair)

	extern float	block_state ();
	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	draw_state;
	extern float	enabled;
	float			this_state;


// Lights off if route not set, or rptr sig at yellow.
	this_state = this_sig_lr (SIGFN_DISTANCE);	// Get state of co-located RPTR head
	if ( this_state !=# SIGASP_CLEAR_2 ||		// Main head not clear?
		!route_set() )					// Switch not set as per link?
	{
		draw_state = 0;					// Lights off
	}
	else
      {
		draw_state = 1;					// Lights on
	}

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-Fog-RIL

// Fog Rptr RI Left

	extern float	block_state ();
	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	draw_state;
	extern float	enabled;
	float			this_state;


// Lights off if route not set, or fog rptr at yellow.
	this_state = this_sig_lr (SIGFN_DISTANCE);	// Get state of co-located fog rptr
	if ( this_state !=# SIGASP_CLEAR_2 ||		// Main head not clear?
		!route_set())					// Switch not set as per link?
	{
		draw_state = 0;					// Lights off
	}
	else
      {
		draw_state = 1;					// Lights on
	}

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-Fog-RIR

// Fog Rptr RI Right

	extern float	block_state ();
	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	draw_state;
	extern float	enabled;
	float			this_state;


// Lights off if route not set, or fog rptr at yellow.
	this_state = this_sig_lr (SIGFN_DISTANCE);	// Get state of co-located fog rptr
	if ( this_state !=# SIGASP_CLEAR_2 ||		// Main head not clear?
		!route_set())					// Switch not set as per link?
	{
		draw_state = 0;					// Lights off
	}
	else
      {
		draw_state = 1;					// Lights on
	}

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-Stop-Repeater

// LUL combined Stop + Repeater( 2 x 2 Aspect)
// Stop shows next block and route link state. If clear, then...
// Repeater shows state of next signal, yellow if next is red.

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float			next_state;

// If required, show the 'stop' indication.
	if (!enabled ||								// Not enabled/cleared to show natural state?
		block_state() !=# BLOCK_CLEAR ||				// Block ahead not clear?
		!route_set())							// Switch not set as per link?
	{
		state = SIGASP_STOP; // single red
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else
	{
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_STOP ||
		    next_state ==# SIGASP_RESTRICTING)
		{
			state = SIGASP_APPROACH_1; // Green home + yellow repeater
		}
		else
		{
			state = SIGASP_CLEAR_2; // Green home + green repeater
		}
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-Stop-Fog

// LUL combined Stop + Fog repeater( 2 x 2 Aspect)
// Stop shows next block and route link state. If clear, then...
// Fog Repeater shows state of next signal, yellow if next is red.

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float			next_state;

// If required, show the 'stop' indication.
	if (!enabled ||								// Not enabled/cleared to show natural state?
		block_state() !=# BLOCK_CLEAR ||				// Block ahead not clear?
		!route_set())							// Switch not set as per link?
	{
	// Main head at STOP. If a co-located shunt link is clear, allow restricted proceed
		if ( this_sig_lr (SIGFN_SHUNTING) ==# SIGASP_CLEAR_2 )
		{
			state = SIGASP_RESTRICTING;	// Allow movement to turnout past main stop head
		}
		else
		{
			state = SIGASP_STOP;	// Neither route clear
		}
	}
// Signal head is enabled and the block ahead is clear and no attached shunt cleared
// Update based on state of next signal head to determine repeater aspect
	else
	{
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_STOP ||
		    next_state ==# SIGASP_RESTRICTING)
		{
			state = SIGASP_APPROACH_1; // Green home + yellow repeater
		}
		else
		{
			state = SIGASP_CLEAR_2; // Green home + green repeater
		}
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-Auto-Repeater

// LUL combined Stop (auto) + Repeater( 2 x 2 Aspect)
// Auto shows next block state. If clear, then...
// Repeater shows state of next signal, yellow if next is red.

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float			next_state;

// If required, show the 'stop' indication.
	if (block_state() !=# BLOCK_CLEAR)				// Block ahead not clear?
	{
		state = SIGASP_STOP; // single red
	}
// Block ahead is clear - update based on state of
// next signal head.
	else
	{
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_STOP ||
		    next_state ==# SIGASP_RESTRICTING)
		{
			state = SIGASP_APPROACH_1; // Green home + yellow repeater
		}
		else
		{
			state = SIGASP_CLEAR_2; // Green home + green repeater
		}
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-Auto-Fog

// LUL combined Stop (auto) + Fog repeater( 2 x 2 Aspect)
// Auto shows next block state. If clear, then...
// Repeater shows state of next signal, yellow if next is red.

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float			next_state;

// If required, show the 'stop' indication.
	if (block_state() !=# BLOCK_CLEAR)				// Block ahead not clear?
	{
		state = SIGASP_STOP; // single red
	}
// Block ahead is clear - update based on state of
// next signal head.
	else
	{
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_STOP ||
		    next_state ==# SIGASP_RESTRICTING)
		{
			state = SIGASP_APPROACH_1; // Green home + yellow repeater
		}
		else
		{
			state = SIGASP_CLEAR_2; // Green home + green repeater
		}
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
//
// LUL Tunnel Signals
//
///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-T-Stop

// 2 Aspect Colour Light Tunnel Stop (semi-auto)

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float			next_state;

// Determine STOP conditions
	if ( !enabled ||								// Not enabled/cleared to show natural state?
		block_state() !=# BLOCK_CLEAR )				// Block ahead not clear?
	{
		state = SIGASP_STOP;
	}
	else
      {
		state = SIGASP_CLEAR_2;  // Path set and block clear
	}

// If a co-located shunt link is clear or our route link is not set, allow restricted proceed
	if ( this_sig_lr (SIGFN_SHUNTING) ==# SIGASP_CLEAR_2 ||
	     !route_set() ) // Switch not set as per link?
	{
		state = SIGASP_RESTRICTING;	// Allow movement to turnout past main stop head
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-T-Auto

// 2 Aspect Colour Light Tunnel Stop (Automatic)
// Only shows STOP if Block ahead is occupied, else clear

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	this_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float			next_state;

// Determine STOP conditions
	if (block_state() !=# BLOCK_CLEAR)				// Block ahead not clear?
	{
		state = SIGASP_STOP;	// Block occupied
	}
	else
      {
		state = SIGASP_CLEAR_2;  // Block clear
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-T-Repeater

// 2 Aspect Colour Light Tunnel Repeater

	extern float	def_draw_state ();
	extern float	next_sig_lr();
	extern float	state;
	extern float	draw_state;
	float			next_state;

	// Find next NORMAL (stop or auto) signal. If at STOP, set Repeater at Approach, else Clear.
	next_state = next_sig_lr (SIGFN_NORMAL);
	if ( next_state ==# SIGASP_STOP ||
	     next_state ==# SIGASP_RESTRICTING )
	{
		state = SIGASP_APPROACH_1; // Yellow
	}
	else
	{
		state = SIGASP_CLEAR_2; // Green
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-T-Stop-Repeater

// LUL combined Tunnel Stop (semi) + Repeater (2 x 2 Aspect)
// Stop shows next block and route link state. If clear, then...
// Repeater shows state of next signal, yellow if next is red.

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float			next_state;

// If required, show the 'stop' indication.
	if (!enabled ||								// Not enabled/cleared to show natural state?
		block_state() !=# BLOCK_CLEAR ||				// Block ahead not clear?
		!route_set())							// Switch not set as per link?
	{
		state = SIGASP_STOP; // single red
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else
	{
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_STOP ||
		    next_state ==# SIGASP_RESTRICTING)
		{
			state = SIGASP_APPROACH_1; // Green home + yellow repeater
		}
		else
		{
			state = SIGASP_CLEAR_2; // Green home + green repeater
		}
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-T-Auto-Repeater

// LUL combined Tunnel Stop (auto) + Repeater( 2 x 2 Aspect)
// Auto shows next block state. If clear, then...
// Repeater shows state of next signal, yellow if next is red.

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float			next_state;

// If required, show the 'stop' indication.
	if (block_state() !=# BLOCK_CLEAR)				// Block ahead not clear?
	{
		state = SIGASP_STOP; // single red
	}
// Block ahead is clear - update based on state of
// next signal head.
	else
	{
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_STOP ||
		    next_state ==# SIGASP_RESTRICTING)
		{
			state = SIGASP_APPROACH_1; // Green home + yellow repeater
		}
		else
		{
			state = SIGASP_CLEAR_2; // Green home + green repeater
		}
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-T-RI-Left

// Tunnel Semi Route Indicator Left
// Lit if route set AND Rptr is green or yellow

	extern float	block_state ();
	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	draw_state;
	extern float	enabled;
	float			this_state;


// Lights off if route not set, or stop sig at red.
	this_state = this_sig_lr (SIGFN_NORMAL);		// Get state of co-located stop head
	if ( this_state ==# SIGASP_STOP ||			// Main head not clear?
		!route_set() )					// Switch not set as per link?
	{
		draw_state = 0;					// Lights off
	}
	else
      {
		draw_state = 1;					// Lights on
	}

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-T-RI-Right

// Tunnel Semi Route Indicator Right
// Lit if route set AND Rptr is green or yellow

	extern float	block_state ();
	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	draw_state;
	extern float	enabled;
	float			this_state;


// Lights off if route not set, or stop sig at red.
	this_state = this_sig_lr (SIGFN_NORMAL);		// Get state of co-located stop head
	if ( this_state ==# SIGASP_STOP ||			// Main head not clear?
		!route_set())					// Switch not set as per link?
	{
		draw_state = 0;					// Lights off
	}
	else
      {
		draw_state = 1;					// Lights on
	}

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-T-Rptr-RI-Left

// Tunnel Repeater Route Indicator Left
// Lit if route set AND Rptr is green

	extern float	block_state ();
	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	draw_state;
	extern float	enabled;
	float			this_state;


// Lights off if route not set, or rptr sig at yellow.
	this_state = this_sig_lr (SIGFN_DISTANCE);	// Get state of co-located rptr head
	if ( this_state !=# SIGASP_CLEAR_2 ||		// Main head not clear?
		!route_set() )					// Switch not set as per link?
	{
		draw_state = 0;					// Lights off
	}
	else
      {
		draw_state = 1;					// Lights on
	}

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-T-Rptr-RI-Right

// Tunnel Repeater Route Indicator Right
// Lit if route set AND Rptr is green

	extern float	block_state ();
	extern float	route_set ();
	extern float	this_sig_lr ();
	extern float	draw_state;
	extern float	enabled;
	float			this_state;


// Lights off if route not set, or rptr sig at yellow.
	this_state = this_sig_lr (SIGFN_DISTANCE);	// Get state of co-located rptr head
	if ( this_state !=# SIGASP_CLEAR_2 ||		// Main head not clear?
		!route_set())					// Switch not set as per link?
	{
		draw_state = 0;					// Lights off
	}
	else
      {
		draw_state = 1;					// Lights on
	}

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-T-TCD

// LUL Track Circuit Detector (A/B/C circuits)
// Reports state of its block and 2 BLOCKS ahead
//
// These must be positioned at pfm end and 1/3 and 2/3 points along.
//
// If our block (A) not clear - STOP, else
// If Block+1 (B) not clear - APPROACH_2, else
// If Block+2 (C) not clear - APPROACH_3, else
// (A/B/C clear) - CLEAR_2

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float			next_state;

// If our block is not clear, show the 'most restrictive' indication.
// Else update based on state of next TCD or Normal signal ahead
// setting us at 1 state less restrictive than the advanced TCD.
// States will ripple through the 3 ABC TCDs as blocks clear.

	if (block_state() !=# BLOCK_CLEAR)
	{
		state = SIGASP_STOP; 	// Our Block not clear (RED)
	}
	else
	{
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_STOP)
		{
			state = SIGASP_APPROACH_2; 	// Block+1 not clear (AMBER)
		}
		else
		{
			if (next_state ==# SIGASP_APPROACH_2)
			{
				state = SIGASP_APPROACH_3; 	// Block+2 not clear (LUNAR)
			}
			else
			{
				state = SIGASP_CLEAR_2; 	// All Blocks clear (GREEN)
			}
		}
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-T-TCR

// LUL Track Circuit (A/B/C circuits) Repeater.
// Signal is of unique type REPEATER so it can be queried by HOME signals.
// Reports state of ABC Block TCD ahead of it.
//
// Must be positioned exactly behind Block A TCD in rear of pfm edge
// and in advance of HOME (C).
//
// If Block (A) not clear - STOP, else
// If Block+1 (B) not clear - APPROACH_2, else
// If Block+2 (C) not clear - APPROACH_3, else
// (A/B/C clear) - CLEAR_2

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float			next_state;

	next_state = next_sig_lr (SIGFN_NORMAL);

	state = next_state; 	// Repeat TCD (A) signal state ahead

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-T-Home-A

// LUL Tunnel Multi-home A Signal
//
// STOP if our block clear, else
// STOP if Block A not clear (TCR = STOP),
// Else Clear_2

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float			next_state;

	if (block_state() !=# BLOCK_CLEAR)
	{
		state = SIGASP_STOP; 
	}
	else
	{
		next_state = next_sig_lr (SIGFN_REPEATER);

		if (next_state ==# SIGASP_STOP) 
		{
			state = SIGASP_STOP; 
		}
		else
		{
			state = SIGASP_CLEAR_2; 
		}
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-T-Home-B

// LUL Tunnel Multi-home B Signal
//
// STOP if our block clear, else
// STOP if Block A or B not clear (TCR = STOP or APPROACH_2),
// Else Clear_2

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float			next_state;

	if (block_state() !=# BLOCK_CLEAR)
	{
		state = SIGASP_STOP; 
	}
	else
	{
		next_state = next_sig_lr (SIGFN_REPEATER);

		if (next_state ==# SIGASP_STOP ||
		    next_state ==# SIGASP_APPROACH_2) 
		{
			state = SIGASP_STOP; 
		}
		else
		{
			state = SIGASP_CLEAR_2; 
		}
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-T-Home-C

// LUL Tunnel Multi-home C Signal
//
// STOP if our block clear, else
// STOP if Block A or B or C not clear (TCR = STOP_1 or APPROACH_2 or APPROACH_3),
// Else Clear_2

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float			next_state;

	if (block_state() !=# BLOCK_CLEAR)
	{
		state = SIGASP_STOP; 
	}
	else
	{
		next_state = next_sig_lr (SIGFN_REPEATER);

		if (next_state ==# SIGASP_STOP ||
		    next_state ==# SIGASP_APPROACH_2 ||
		    next_state ==# SIGASP_APPROACH_3) 
		{
			state = SIGASP_STOP; 
		}
		else
		{
			state = SIGASP_CLEAR_2; 
		}
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-Home-A

// LUL Multi-home A Signal
//
// STOP if our block clear, else
// STOP if Block A not clear (TCR = STOP),
// Else Clear_2

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float			next_state;

	if (block_state() !=# BLOCK_CLEAR)
	{
		state = SIGASP_STOP; 
	}
	else
	{
		next_state = next_sig_lr (SIGFN_REPEATER);

		if (next_state ==# SIGASP_STOP) 
		{
			state = SIGASP_STOP; 
		}
		else
		{
			state = SIGASP_CLEAR_2; 
		}
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-Home-B

// LUL Multi-home B Signal
//
// STOP if our block clear, else
// STOP if Block A or B not clear (TCR = STOP or APPROACH_2),
// Else Clear_2

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float			next_state;

	if (block_state() !=# BLOCK_CLEAR)
	{
		state = SIGASP_STOP; 
	}
	else
	{
		next_state = next_sig_lr (SIGFN_REPEATER);

		if (next_state ==# SIGASP_STOP ||
		    next_state ==# SIGASP_APPROACH_2) 
		{
			state = SIGASP_STOP; 
		}
		else
		{
			state = SIGASP_CLEAR_2; 
		}
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT LUL-Home-C

// LUL Multi-home C Signal
//
// STOP if our block clear, else
// STOP if Block A or B or C not clear (TCR = STOP_1 or APPROACH_2 or APPROACH_3),
// Else Clear_2

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float			next_state;

	if (block_state() !=# BLOCK_CLEAR)
	{
		state = SIGASP_STOP; 
	}
	else
	{
		next_state = next_sig_lr (SIGFN_REPEATER);

		if (next_state ==# SIGASP_STOP ||
		    next_state ==# SIGASP_APPROACH_2 ||
		    next_state ==# SIGASP_APPROACH_3) 
		{
			state = SIGASP_STOP; 
		}
		else
		{
			state = SIGASP_CLEAR_2; 
		}
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

// End of File
